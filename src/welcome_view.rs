// Generated by RustGObjectGenerator
// This file is licensed under the same terms as the project it belongs to

use adw::subclass::prelude::*;
use glib::Properties;
use glib::clone;
use gtk::{gio, glib, prelude::*};
use std::cell::RefCell;

mod imp {
    use crate::{
        root_store::RootStore, tagged_object::TaggedObject, terminal_combo_row::TerminalComboRow,
    };

    use super::*;

    #[derive(Properties, Default, gtk::CompositeTemplate)]
    #[properties(wrapper_type = super::WelcomeView)]
    #[template(file = "welcome_view.ui")]
    pub struct WelcomeView {
        #[property(get, set)]
        root_store: RefCell<RootStore>,

        #[property(get, set, nullable)]
        distrobox_error: RefCell<Option<String>>,
        #[property(get, set, nullable)]
        terminal_error: RefCell<Option<String>>,

        #[template_child]
        carousel: TemplateChild<adw::Carousel>,
        #[template_child]
        terminal_preferences_page: TemplateChild<adw::Clamp>,
        #[template_child]
        distrobox_page: TemplateChild<adw::Clamp>,
        #[template_child]
        terminal_combo_row: TemplateChild<TerminalComboRow>,
        #[template_child]
        pub use_bundled_btn: TemplateChild<gtk::Button>,
    }

    #[glib::derived_properties]
    impl ObjectImpl for WelcomeView {}

    #[glib::object_subclass]
    impl ObjectSubclass for WelcomeView {
        const NAME: &'static str = "WelcomeView";
        type Type = super::WelcomeView;
        type ParentType = adw::Bin;

        fn class_init(klass: &mut Self::Class) {
            klass.bind_template();
            klass.bind_template_callbacks();
        }

        fn instance_init(obj: &glib::subclass::InitializingObject<Self>) {
            obj.init_template();
        }
    }

    impl WidgetImpl for WelcomeView {}
    impl BinImpl for WelcomeView {}

    #[gtk::template_callbacks]
    impl WelcomeView {
        #[template_callback]
        fn continue_to_terminal_page(&self, _: &gtk::Button) {
            let obj = self.obj();
            let obj_clone = obj.clone();
            obj.root_store()
                .distrobox_version()
                .connect_success(move |_version| {
                    obj_clone
                        .imp()
                        .carousel
                        .scroll_to(&*obj_clone.imp().terminal_preferences_page, true);
                });
            let obj_clone = obj.clone();
            obj.root_store()
                .distrobox_version()
                .connect_error(move |error| {
                    obj_clone.set_distrobox_error(Some(error.to_string()));
                });
            self.obj().root_store().distrobox_version().refetch();
            self.obj().root_store().load_containers();
        }
        #[template_callback]
        fn continue_to_app(&self, _: &gtk::Button) {
            let obj = self.obj().clone();
            if obj.root_store().selected_terminal().is_some() {
                glib::MainContext::ref_thread_default().spawn_local(async move {
                    match obj.root_store().validate_terminal().await {
                        Ok(_) => {
                            obj.root_store().set_current_view(TaggedObject::new("main"));
                        }
                        Err(err) => {
                            obj.set_terminal_error(Some(format!("{}", err)));
                        }
                    }
                });
            }
        }
        #[template_callback]
        fn use_bundled_version(&self, btn: &gtk::Button) {
            let obj = self.obj();

            // Show spinner in button
            let spinner = gtk::Spinner::new();
            spinner.start();
            btn.set_child(Some(&spinner));
            btn.set_sensitive(false);

            // Directly trigger the download and get the task
            let task = obj.root_store().download_distrobox();

            // Connect to the task status changes
            task.connect_status_notify(clone!(
                #[weak]
                obj,
                #[strong]
                btn,
                move |task| {
                    if task.status() == "successful" {
                        obj.imp()
                            .carousel
                            .scroll_to(&*obj.imp().terminal_preferences_page, true);
                    } else if task.status() == "failed" {
                        btn.set_child(Some(&gtk::Label::new(Some("Use Bundled Version"))));
                        btn.set_sensitive(true);
                        obj.set_distrobox_error(Some(
                            "Download failed. Check the task manager for details.".to_string(),
                        ));
                    }
                }
            ));

            // Open task manager dialog from welcome view
            obj.root_store()
                .set_current_dialog(crate::tagged_object::TaggedObject::new("task-manager"));

            // Set the preference for future launches
            let settings = gio::Settings::new("com.ranfdev.DistroShelf");
            let _ = settings.set_string("distrobox-executable", "bundled");
        }
    }
}

glib::wrapper! {
    pub struct WelcomeView(ObjectSubclass<imp::WelcomeView>)
        @extends adw::Bin, gtk::Widget,
        @implements gtk::Accessible, gtk::Buildable, gtk::ConstraintTarget;
}
